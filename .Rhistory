x ="Amount of Treated"
) +
theme_light()
rzp_tree_mat_conv <- matching_evaluation(pred, "control")
rzp_tree_mat_conv %>% ggplot(aes(x = Percentile)) +
geom_line(aes_string(y = rzp_tree_mat_conv[, colnames(rzp_tree_mat_conv)[4]]) ) +
labs(
title = "Dynamic Treatment Curve - Rzpk Tree",
y = "Uplift",
x ="Amount of Treated"
) +
theme_light()
# Import data and creat Train / Test splits
data <-  read.csv('Email.csv')
source('X Model Approach.R')
data$visit <- NULL
data$spend <- NULL
## Set these values depending on the dataset
# Treatment column in data
treatment <- "segment"
# Response column
response <-  "conversion"
# String Level of the control Level in Treatment column
control_level <- "No E-Mail"
# Get the training and testing data as list
# creates k + 1 train test sets (for each T and control model)
train_test_list <- multiple_train_test_split(data, response, treatment, control_level, 0.7)
train_data <- train_test_list[1][[1]]
test_data <- train_test_list[[2]]
models_clas_dt <- dt_models(train_data, response, "class")
# Calculated Upflift for each individual and Treatment and chosen Treatment
pred_sma_con_dt <- dt_x_model_predictions(models_clas_dt, test_data, response, treatment, control_level, "class")
View(pred_sma_con_dt)
# Expected Response per targeted customers
sma_dt_conv_exp <- expected_percentile_response(pred_sma_con_dt)
sma_dt_conv_mat <- matching_evaluation(pred_sma_con_dt, "Control")
View(pred_sma_con_dt)
levels(as.factor(pred_sma_con_dt))
levels(as.factor(pred_sma_con_dt$Treatment))
levels(as.factor(pred_sma_con_dt$T_index))
# Calculated Upflift for each individual and Treatment and chosen Treatment
#pred_sma_con_dt
tmp<- dt_x_model_predictions(models_clas_dt, test_data, response, treatment, control_level, "class")
View(tmp)
tmp$T_index <- apply(tmp[, 1:3], 1, which.max)
levels(as.factor(tmp$T_index))
dt_models <- function(train_data, response, prediction_method){
# for each element in train data fir model and return list of models
treatments <- names(train_data)
models <- list()
for(i in c(1: length(treatments))){
train <- train_data[[i]]
# Grow the tree
## TODO how to set / adjust parameters ??
dt <- rpart(as.formula(paste(response, "~.")), train, method = prediction_method, control=rpart.control(minsplit=8,  cp=0.005))
models <- append(models, list(x= dt))
}
names(models) <- treatments
# Named list with fitted models for each treatment and control
return(models)
}
models_clas_dt <- dt_models(train_data, response, "class")
# Calculated Upflift for each individual and Treatment and chosen Treatment
#pred_sma_con_dt
tmp<- dt_x_model_predictions(models_clas_dt, test_data, response, treatment, control_level, "class")
# Expected Response per targeted customers
sma_dt_conv_exp <- expected_percentile_response(pred_sma_con_dt)
sma_dt_conv_mat <- matching_evaluation(pred_sma_con_dt, "Control")
dt_models <- function(train_data, response, prediction_method){
# for each element in train data fir model and return list of models
treatments <- names(train_data)
models <- list()
for(i in c(1: length(treatments))){
train <- train_data[[i]]
# Grow the tree
## TODO how to set / adjust parameters ??
dt <- rpart(as.formula(paste(response, "~.")), train, method = prediction_method, control=rpart.control(minsplit=5,  cp=0.0001))
models <- append(models, list(x= dt))
}
names(models) <- treatments
# Named list with fitted models for each treatment and control
return(models)
}
models_clas_dt <- dt_models(train_data, response, "class")
# Calculated Upflift for each individual and Treatment and chosen Treatment
#pred_sma_con_dt
tmp<- dt_x_model_predictions(models_clas_dt, test_data, response, treatment, control_level, "class")
# Calculated Upflift for each individual and Treatment and chosen Treatment
pred_sma_con_dt <- dt_x_model_predictions(models_clas_dt, test_data, response, treatment, control_level, "class")
# Expected Response per targeted customers
sma_dt_conv_exp <- expected_percentile_response(pred_sma_con_dt)
# Expected Response per targeted customers
sma_dt_conv_exp <- expected_percentile_response(pred_sma_con_dt)
sma_dt_conv_mat <- matching_evaluation(pred_sma_con_dt, "Control")
# Creates k + 1 Logit models for binary response
models_logit <- logit_models(train_data, response)
## Evaluate Models on Test data
# Calculated Upflift for each individual and Treatment and chosen Treatment
predictions_logit <- logit_x_model_predictions(models_logit, test_data, response, treatment, control_level)
# Zhao
sma_logit_conv_exp <- expected_percentile_response(predictions_logit)
sma_logit_conv_mat <- matching_evaluation(predictions_logit, "Control")
#################
## Random Forest
rf_models <- rf_models(train_data, response, "class")
rf_pred_class <- dt_x_model_predictions(rf_models, test_data, response, treatment, control_level, "class")
# Expected Response per targeted customers
sma_rf_conv_exp <- expected_percentile_response(rf_pred_class)
sma_rf_conv_mat <- matching_evaluation(rf_pred_class, "Control")
ggplot(data = sma_dt_conv_mat, aes(x = Percentile)) +
geom_line(aes_string(y = sma_dt_conv_mat[, colnames(sma_dt_conv_mat)[4]]) ) +
geom_line(aes_string(y = sma_logit_conv_mat[, colnames(sma_logit_conv_mat)[4]]) ) +
geom_line(aes_string(y = sma_rf_conv_mat[, colnames(sma_rf_conv_mat)[4]]) ) +
labs(
title = "Dynamic Treatment Curve",
y = "Uplift",
x ="Amount of Treated"
) +
theme_light()
ggplot(data = sma_dt_conv_mat, aes(x = Percentile)) +
geom_line(aes_string(y = sma_dt_conv_mat[, colnames(sma_dt_conv_mat)[4]]) ) +
geom_line(aes_string(y = sma_logit_conv_mat[, colnames(sma_logit_conv_mat)[4]]) ) +
geom_line(aes_string(y = sma_rf_conv_mat[, colnames(sma_rf_conv_mat)[4]]) ) +
labs(
color="Indices",
title = "Dynamic Treatment Curve",
y = "Uplift",
x ="Amount of Treated"
) +
theme_light()
ggplot(data = sma_dt_conv_mat, aes(x = Percentile)) +
geom_line(aes_string(y = sma_dt_conv_mat[, colnames(sma_dt_conv_mat)[4]]) ) +
geom_line(aes_string(y = sma_logit_conv_mat[, colnames(sma_logit_conv_mat)[4]]) ) +
geom_line(aes_string(y = sma_rf_conv_mat[, colnames(sma_rf_conv_mat)[4]]) ) +
scale_color_manual(values = c("red", "blue", "green")) +
labs(
color="Indices",
title = "Dynamic Treatment Curve",
y = "Uplift",
x ="Amount of Treated"
) +
theme_light()
ggplot(data = sma_dt_conv_mat, aes(x = Percentile)) +
geom_line(aes_string(y = sma_dt_conv_mat[, colnames(sma_dt_conv_mat)[4]] , color='DT') ) +
geom_line(aes_string(y = sma_logit_conv_mat[, colnames(sma_logit_conv_mat)[4]] , color='Logit') ) +
geom_line(aes_string(y = sma_rf_conv_mat[, colnames(sma_rf_conv_mat)[4]], color='RF') ) +
scale_color_manual(values = c("red", "blue", "green")) +
labs(
color="Indices",
title = "Dynamic Treatment Curve",
y = "Uplift",
x ="Amount of Treated"
) +
theme_light()
sma_dt_conv_mat
sma_logit_conv_mat
melt(rbind(smalogit_conv_mat, sma_dt_conv_mat, sma_rf_conv_mat, C), id.vars = c("Percentile")))
melt(rbind(smalogit_conv_mat, sma_dt_conv_mat, sma_rf_conv_mat, C), id.vars = c("Percentile"))
melt(rbind(sma_logit_conv_mat, sma_dt_conv_mat, sma_rf_conv_mat, C), id.vars = c("Percentile"))
rbind(sma_logit_conv_mat, sma_dt_conv_mat, sma_rf_conv_mat)
melt(rbind(sma_logit_conv_mat, sma_dt_conv_mat, sma_rf_conv_mat), id.vars = c("Percentile"))
sma_rf_conv_exp$Model <- sma_rf_conv_mat$Model <- "RF"
sma_dt_conv_exp$Model <- sma_dt_conv_mat$Model <- "DT"
sma_logit_conv_exp$Model <- sma_logit_conv_mat$Model <- "Logit"
melt(rbind(sma_logit_conv_mat, sma_dt_conv_mat, sma_rf_conv_mat), id.vars = c("Percentile","Model"))
View(sma_dt_conv_mat)
melt(rbind(sma_logit_conv_mat[, c("Percentile","Model","max T")], sma_dt_conv_mat[, c("Percentile","Model","max T")], sma_rf_conv_mat[, c("Percentile","Model","max T")]), id.vars = c("Percentile","Model"))
melt(rbind(sma_logit_conv_mat[, c("Percentile","Model","max T")], sma_dt_conv_mat[, c("Percentile","Model","max T")], sma_rf_conv_mat[, c("Percentile","Model","max T")]), id.vars = c("Percentile","Model")) %>% ggplot(aes(x = Percentile)) +
geom_line(aes(y = value, group= Model, color= Model) ) +
scale_color_manual(values = c("red", "blue", "green")) +
labs(
color="Indices",
title = "Dynamic Treatment Curve",
y = "Uplift",
x ="Amount of Treated"
) +
theme_light()
melt(rbind(sma_logit_conv_mat[, c("Percentile","Model","max T")], sma_dt_conv_mat[, c("Percentile","Model","max T")], sma_rf_conv_mat[, c("Percentile","Model","max T")]), id.vars = c("Percentile","Model")) %>% ggplot(aes(x = Percentile)) +
geom_line(aes(y = value, group= Model, color= Model) ) +
#scale_color_manual(values = c("red", "blue", "green")) +
labs(
color="Models",
title = "SMA - Dynamic Treatment Curve",
y = "Uplift",
x ="Amount of Treated"
) +
theme_light()
melt(rbind(sma_logit_conv_mat[, c("Percentile","Model","max T")], sma_dt_conv_mat[, c("Percentile","Model","max T")], sma_rf_conv_mat[, c("Percentile","Model","max T")]), id.vars = c("Percentile","Model")) %>% ggplot(aes(x = Percentile)) +
geom_line(aes(y = value, group= Model, color= Model) ) +
#scale_color_manual(values = c("red", "blue", "green")) +
labs(
color="Base Learner",
title = "SMA - Dynamic Treatment Curve",
y = "Conversion Increase",
x ="Amount of Treated"
) +
theme_light()
sma_logit_conv_exp
melt(rbind(sma_logit_conv_exp[, c("Percentile","Model","Expected Outcome")], sma_dt_conv_mat[, c("Percentile","Model","Expected Outcome")], sma_rf_conv_mat[, c("Percentile","Model","Expected Outcome")]), id.vars = c("Percentile","Model"))
melt(rbind(sma_logit_conv_exp[, c("Percentile","Model","Expected Outcome")], sma_dt_conv_exp[, c("Percentile","Model","Expected Outcome")], sma_rf_conv_exp[, c("Percentile","Model","Expected Outcome")]), id.vars = c("Percentile","Model"))
melt(rbind(sma_logit_conv_exp[, c("Percentile","Model","Expected Outcome")], sma_dt_conv_exp[, c("Percentile","Model","Expected Outcome")], sma_rf_conv_exp[, c("Percentile","Model","Expected Outcome")]), id.vars = c("Percentile","Model")) %>% ggplot(aes(x = Percentile)) +
geom_line(aes(y = value, group= Model, color= Model) ) +
labs(
color="Base Learner",
title = "SMA - Dynamic Treatment Curve",
y = "Expected Outcome",
x ="Amount of Treated"
) +
theme_light()
source('CausalTree.R')
#install.packages("devtools")
#library(devtools)
install_github("susanathey/causalTree")
install.packages("devtools")
library(devtools)
install_github("susanathey/causalTree")
library(causalTree)
install_github("susanathey/causalTree")
library(causalTree)
install_github("susanathey/causalTree")
install_github("susanathey/causalTree")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(caret)
library(dplyr)
library(reshape2)
source('DecisionTreeImplementation.R')
source('Evaluation Methods.R')
source('DecisionTreeImplementation.R')
source('Evaluation Methods.R')
source('X Model Approach.R')
library(dplyr)
library(reshape2)
source('DecisionTreeImplementation.R')
source('Evaluation Methods.R')
source('X Model Approach.R')
library(DMwR)
set.seed(1234)
pred <- read.csv('rzp tree pred.csv')
eval_data <- pred
# Number of observations
N <- nrow(eval_data)
# Frequencies of treatments z_i
t <- table(eval_data$Assignment)
p_i <- data.frame(t/ nrow(eval_data))
colnames(p_i) <- c("Assignment", "Freq")
# only include points where the assigned treatment equals the predicted
matching <- eval_data[eval_data$Treatment == eval_data$Assignment , ]
matching <- merge(matching, p_i, all.x = T )
##TODO
# print how many have been matched
print(N)
##TODO
# print how many have been matched
print(N, nrow(matching))
##TODO
# print how many have been matched
print(paste(N, nrow(matching)))
matching
aggregate(Assignment~Outcome,matching, length / N)
aggregate(Assignment~Outcome,matching, length )
aggregate(Assignment~Outcome,matching, length ) / N
aggregate(Assignment~Outcome,matching, length )$Assignment / N
print(aggregate(Assignment~Outcome,matching, length ))
print(paste(N,aggregate(Assignment~Outcome,matching, length )))
print(N,aggregate(Outcome~Assignment,matching, length ))
print(aggregate(Outcome~Assignment,matching, length ))
# As described in Zhao et al. 2017
expected_outcome <- function(eval_data){
# Number of observations
N <- nrow(eval_data)
# Frequencies of treatments z_i
t <- table(eval_data$Assignment)
p_i <- data.frame(t/ nrow(eval_data))
colnames(p_i) <- c("Assignment", "Freq")
# only include points where the assigned treatment equals the predicted
matching <- eval_data[eval_data$Treatment == eval_data$Assignment , ]
matching <- merge(matching, p_i, all.x = T )
##TODO
# print how many have been matched
print(paste("Total ",N))
print(aggregate(Outcome~Assignment,matching, length ))
# Expected value of response as AVG sum of outcomes / probability of Assignment
res <- (sum(matching$Outcome / matching$Freq) / N)
return(res)
}
# Expected Response per targeted customers
rzp_tree_exp_conv <- expected_percentile_response(pred)
print(aggregate(Outcome~Assignment,matching, length ))
x<- 0.3
predictions <- pred
# for top x set T to max T
predictions$T_index <- apply(predictions[, 1:2], 1, which.max)
# Assign optimal treatment for all
predictions$Treatment <- colnames(predictions)[predictions$T_index]
# For all who are not in top x Percentile assign Control Treatment
predictions$Treatment[predictions$max_uplift < quantile(predictions$max_uplift,prob=(1-x))] <- "Control"
eval_data <- predictions
# Number of observations
N <- nrow(eval_data)
# Frequencies of treatments z_i
t <- table(eval_data$Assignment)
p_i <- data.frame(t/ nrow(eval_data))
colnames(p_i) <- c("Assignment", "Freq")
# only include points where the assigned treatment equals the predicted
matching <- eval_data[eval_data$Treatment == eval_data$Assignment , ]
matching <- merge(matching, p_i, all.x = T )
##TODO
# print how many have been matched
print(paste("Total ",N))
print(aggregate(Outcome~Assignment,matching, length ))
View(eval_data)
levels(as.facotr(pred$Assignment))
levels(as.factor(pred$Assignment))
levels(as.factor(eval_data$Assignment))
levels(as.factor(matching$Assignment))
print(aggregate(Outcome~Assignment,matching, length ))
View(matching)
matching
levels(as.factor(matching$Assignment))
matching[matching$Assignment == 'control', ]
matching[matching$Assignment == 'Control', ]
matching[matching$Treatment == 'Control', ]
levels(as.factor(pred$Treatment))
levels(as.factor(pred$Assignment))
levels(as.factor(pred$Treatment))
levels(as.factor(pred$Assignment))
#control_level <-
unique(predictions$Assignment)
#control_level <-
unique(predictions$Assignment) %>% class()
control_level <- if (nrow(predictions[predictions$Assignment == 'control']) == 0) "Control" else "control"
control_level <- if (nrow(predictions[predictions$Assignment == 'control' , ]) == 0) "Control" else "control"
control_level
## Modified Uplift Curve by Zhao
# *Assumption* outcome for each treatment equals prediction of model
expected_percentile_response <- function(predictions){
#N <- nrow(predictions)
# Choose only the uplift columns
predictions$max_uplift <- apply(predictions[ , grep("^Uplift",colnames(predictions))], 1 , max)
predictions$max_treatment_outcome <- apply(predictions[ , c(1: (length(levels(as.factor(predictions$Assignment))) - 1)  )], 1 , max)
# Sum percentiles
ret <- data.frame(matrix(ncol = 2, nrow = 0))
control_level <- if (nrow(predictions[predictions$Assignment == 'control' , ]) == 0) "Control" else "control"
for(x in seq(0,1, 0.1)){
# for top x set T to max T
predictions$T_index <- apply(predictions[, 1:2], 1, which.max)
# Assign optimal treatment for all
predictions$Treatment <- colnames(predictions)[predictions$T_index]
# For all who are not in top x Percentile assign Control Treatment
# For implementation of Matthias lower case control...
predictions$Treatment[predictions$max_uplift < quantile(predictions$max_uplift,prob=(1-x))] <- control_level
# Calculate the Expected Response Value top Percentile
ret <- rbind(ret, c(x, expected_outcome(predictions)) )
}
colnames(ret) <- c("Percentile", "Expected Outcome")
return(ret)
}
pred <- read.csv('rzp tree pred.csv')
# Expected Response per targeted customers
rzp_tree_exp_conv <- expected_percentile_response(pred)
c_tree_mat_conv <- matching_evaluation(causal_pred, "control")
# Evaluate pre saved Causal Tree results
causal_pred <- read.csv("old - causal tree pred.csv")
c_tree_mat_conv <- matching_evaluation(causal_pred, "control")
c_tree_mat_conv
library(ggplot2)
library(dplyr)
library(reshape2)
source('DecisionTreeImplementation.R')
source('DecisionTreeImplementation.R')
source('Evaluation Methods.R')
source('X Model Approach.R')
library(DMwR)
set.seed(1234)
##TODO
#already split the data here and only process later...
#Data import
email <- read.csv('Email.csv')
email$men_treatment <- ifelse(email$segment=='Mens E-Mail',1,0)
email$women_treatment <- ifelse(email$segment=='Womens E-Mail',1,0)
email$control <- ifelse(email$segment=='No E-Mail',1,0)
email$mens <- as.factor(email$mens)
email$womens <- as.factor(email$womens)
email$newbie <- as.factor(email$newbie)
email$visit <- email$spend <- email$segment <- NULL
response <- 'conversion'
# Split into test and train data
idx <- createDataPartition(y = email[ , response], p=0.3, list = FALSE)
train <- email[-idx, ]
test <- email[idx, ]
treatment_list <- c('men_treatment','women_treatment')
test_list <- set_up_tests(train[,c("recency","history_segment","history","mens","womens","zip_code",
"newbie","channel")],TRUE)
raw_tree <- create_node(train,0,100,treatment_list,'conversion','control',test_list) #conversion
# Partition training data for pruning
p_idx <- createDataPartition(y = train[ , response], p=0.3, list = FALSE)
# takes a lot of time..
#conversion
pruned_tree <- prune_tree(raw_tree,train[p_idx,],train[-p_idx,],target = 'conversion') #conversion
# add to the result df the outcome, assignment and calculate uplift for each T
pred <- predict.dt.as.df(pruned_tree, test)
### Results Preparation to bring into equal format
# Calculate Uplift for each T
pred[ , "Uplift - Mens E-Mail"] <- pred[ , 1] - pred[ , 3]
pred[ , "Uplift - Womens E-Mail"] <- pred[ , 2] - pred[ , 3]
pred[ , "Treatment"] <- colnames(pred)[apply(pred[, 1:3], 1, which.max)]
pred[ , "Outcome"] <- test[, response]
# get the actual assignment from test data
pred[ , "Assignment"] <- colnames(test)[apply(test[, 10:12], 1, which.max) + 9]
write.csv(pred, 'rzp tree pred.csv', row.names = FALSE)
# Expected Response per targeted customers
rzp_tree_exp_conv <- expected_percentile_response(pred)
rzp_tree_mat_conv <- matching_evaluation(pred, "control")
source('CausalTree.R')
causal_pred <- causalTreePredicitons(train, test, treatment_list)
causal_pred
## TODO
# use new data...
write.csv(causal_pred, "causal tree pred.csv", row.names = FALSE)
source('DecisionTreeImplementation.R')
##TODO
#already split the data here and only process later...
#Data import
email <- read.csv('Email.csv')
##TODO
#already split the data here and only process later...
#Data import
email <- read.csv('Email.csv')
email$men_treatment <- ifelse(email$segment=='Mens E-Mail',1,0)
email$control <- ifelse(email$segment=='No E-Mail',1,0)
email$mens <- as.factor(email$mens)
email$womens <- as.factor(email$womens)
email$newbie <- as.factor(email$newbie)
email$visit <- email$spend <- email$segment <- NULL
data <-  read.csv('Email.csv')
data$visit <- NULL
data$conversion <- NULL
## Set these values depending on the dataset
# Treatment column in data
treatment <- "segment"
# Response column
response <-  "spend"
# String Level of the control Level in Treatment column
control_level <- "No E-Mail"
demo()
setwd("C:/Users/Jan/Desktop/Predictive Analytics/APA")
source('DecisionTreeImplementation.R')
source('Separate Model Approach.R')
source('Causal Forest.R')
source('Evaluation Methods.R')
set.seed(123)
#####################################################################################
### Conversion Prediction
#####################################################################################
#Data import
raw_email <- read.csv('Email.csv')
response <- 'conversion'
k <- 5
folds <- createFolds(raw_email[, response], k = k)
raw_email$fold <- 0
for(f in names(folds)){
  raw_email[folds[f][[1]] , "fold"] <- f
}
email <- raw_email
email$men_treatment <- ifelse(email$segment=='Mens E-Mail',1,0)
email$women_treatment <- ifelse(email$segment=='Womens E-Mail',1,0)
email$control <- ifelse(email$segment=='No E-Mail',1,0)
email$mens <- as.factor(email$mens)
email$womens <- as.factor(email$womens)
email$newbie <- as.factor(email$newbie)
email$visit<- email$spend <- email$segment <- NULL
#################################
raw_email <- NULL
########
# Fit Rzp Tree
rzp_tree_exp_conv <- rzp_tree_up_conv <- NULL
for(f in names(folds)){
  # split into train and test
  train <- email[email$fold != f , ]
  test <- email[email$fold == f , ]
  train$fold <- test$fold <- NULL
  # Partition training data for pruning
  p_idx <- createDataPartition(y = train[ , response], p=0.3, list = FALSE)
  val <- train[p_idx,]
  train_tree <- train[-p_idx,]
  treatment_list <- c('men_treatment','women_treatment')
  test_list <- set_up_tests(train_tree[,c("recency","history_segment","history","mens","womens","zip_code",
                                          "newbie","channel")],TRUE)
  raw_tree <- create_node(train_tree,0,100,treatment_list,response,'control',test_list)
  pruned_tree <- prune_tree(raw_tree,val,train_tree,target = response)
  # add to the result df the outcome, assignment and calculate uplift for each T
  pred <- predict.dt.as.df(pruned_tree, test)
  ### Results Preparation to bring into equal format
  # Calculate Uplift for each T
  pred[ , "uplift_men_treatment"] <- pred[ , 1] - pred[ , 3]
  pred[ , "uplift_women_treatment"] <- pred[ , 2] - pred[ , 3]
  pred[ , "Treatment"] <- colnames(pred)[apply(pred[, 1:3], 1, which.max)]
  pred[ , "Outcome"] <- test[, response]
  # get the actual assignment from test data
  pred[ , "Assignment"] <- colnames(test)[apply(test[, 10:12], 1, which.max) + 9]
  # bind  matching and expected outcome evaluation
  rzp_tree_exp_conv <- rbind(rzp_tree_exp_conv, expected_percentile_response(pred))
  rzp_tree_up_conv <- rbind(rzp_tree_up_conv, uplift_curve(pred, "control"))
}
#aggregate by percentile r0esults of all models with mean 
rzp_tree_exp_conv <- aggregate(.~Percentile, rzp_tree_exp_conv, mean)
rzp_tree_up_conv <- aggregate(.~Percentile, rzp_tree_up_conv, mean)
write.csv(rzp_tree_exp_conv, 'CSV/rzp_tree_exp_conv.csv', row.names = FALSE)
write.csv(rzp_tree_up_conv, 'CSV/rzp_tree_up_conv.csv', row.names = FALSE)
q()
